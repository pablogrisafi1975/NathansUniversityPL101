<html>
<head>
  <meta charset="utf-8">
  <title>Scheem Tests</title>
  <link rel="stylesheet" href="http://nathansuniversity.com/css/mocha.css" />
  <script src= "http://nathansuniversity.com/js/jquery-1.7.1.min.js"></script>
  <script src= "http://nathansuniversity.com/js/chai.js"></script>
  <script src="http://nathansuniversity.com/js/mocha.js"></script>
  <script src="parser.js"></script>
  <script src="interpreter.js"></script>
  <script>mocha.setup('tdd')</script>
  <script>
  
var expect = chai.expect;    
var assert = chai.assert;


/*
    Numbers done
	Add minus and time and div (no test for div, but done)
    Variable references done
    begin done
    quote done
	cons, car, cdr done
    =, done
	if, done
	<, done
	
    update the way environments are handled to the new way throughout your existing interpreter. done
    Update define, set!, and variable references. done
    Use your lookup, update, and add_binding functions . done
    Add in some more error checking, help save your sanity later. done
    fix your update function so that it works if env is { } done
   
    function values with exactly one argument. done
    function values with exactly zero arguments. done
    function values with many arguments. done
	
	lambda-one. Make sure it works with existing features. Add some tests to make sure it's behaving as you expect. done
	lambda
    Defining a function done
    Simple function calls done
    Calling an anonymous function done
    Passing a function as a value to another function done
    Inner function uses values from enclosing function done
    Argument to a function shadows a global variable done
    A function modifies a global variable done
    An inner function modifies a variable in the outer function done
    An outer function returns an inner function done
    An outer function returns an inner function, inner function refers to outer function variables done
    A function in a define that calls itself recursively done

	Convert everything you can into a function that is bound in the initial environment rather than a special form. deon

*/


suite ('auxiliar functions', function(){
    test('isDefined true', function() {
	    var obj = {a: 33}
        assert.deepEqual(
            Interpreter.isDefined(obj['a']), true);
    });
    test('isDefined false', function() {
	    var obj = {a: 33}
        assert.deepEqual(
            Interpreter.isDefined(obj['b']), false);
    });
	
    test('lookup single binding', function() {
	    var env1 = { bindings: {'x': 19}, outer: { } };
        assert.deepEqual(
            Interpreter.lookup(env1, 'x'), 19);
    });	
    test('lookup double binding inner', function() {
	    var env1 = { bindings: {'x': 19}, outer: { } };
		var env2 = { bindings: {'y': 16}, outer: env1 };		
        assert.deepEqual(
            Interpreter.lookup(env2, 'y'), 16);
    });	
    test('lookup double binding outer', function() {
	    var env1 = { bindings: {'x': 19}, outer: { } };
		var env2 = { bindings: {'y': 16}, outer: env1 };		
        assert.deepEqual(
            Interpreter.lookup(env2, 'x'), 19);
    });		
    test('lookup triple binding inner', function() {
	    var env1 = { bindings: {'x': 19}, outer: { } };
		var env2 = { bindings: {'y': 16}, outer: env1 };	
		var env3 = { bindings: {'x': 2}, outer: env2 };		
        assert.deepEqual(
            Interpreter.lookup(env3, 'x'), 2);
    });		
	
    test('update single binding', function() {
		var env1 = { bindings: {'x': 19}, outer: { } };
		var env1u = { bindings: {'x': 20}, outer: { } };
		Interpreter.update(env1, 'x', 20);
        assert.deepEqual(env1 , env1u);
    });		
    test('update double binding inner', function() {
		var env2 = { bindings: {'y': 16}, outer: { bindings: {'x': 19}, outer: { } }};
		var env2u = { bindings: {'y': 10}, outer:{ bindings: {'x': 19}, outer: { } }};
		Interpreter.update(env2, 'y', 10);
        assert.deepEqual(env2, env2u);
    });	
	test('update double binding outter', function() {
		var env2 = { bindings: {'y': 16}, outer: { bindings: {'x': 19}, outer: { } }};
		var env2u = { bindings: {'y': 16}, outer:{ bindings: {'x': 20}, outer: { } }};
		Interpreter.update(env2, 'x', 20);
        assert.deepEqual(env2, env2u);
    });	
	test('update triple binding inner', function() {
		var env3 = { bindings: {'x': 2}, outer: { bindings: {'y': 16}, outer: { bindings: {'x': 19}, outer: { } }}};
		var env3u = { bindings: {'x': 9}, outer: { bindings: {'y': 16}, outer: { bindings: {'x': 19}, outer: { } }}};
		Interpreter.update(env3, 'x', 9);
        assert.deepEqual(env3, env3u);
    });	
	
	test('update emtpy env', function() {
		var env = {};
		Interpreter.update(env, 'x', 9);
        assert.deepEqual(env, {bindings:{x:9}, outer:{}});
    });		
	
    test('add binding simple new binding', function() {
		var env1 =  { bindings: {'x': 19}, outer: { } };
		var env1u = { bindings: {'x': 19, 'y': 3}, outer: { } };
		Interpreter.add_binding(env1, 'y', 3);
        assert.deepEqual(env1 , env1u);
    });		
    test('add binding New binding', function() {
		var env2 = { bindings: {'y': 16}, outer: { bindings: {'x': 19}, outer: { } }};
		var  env2u = { bindings: {'z': 9, 'y': 16}, outer: { bindings: {'x': 19}, outer: { } }};
		Interpreter.add_binding(env2, 'z', 9);
        assert.deepEqual(env2 , env2u);
    });		
});


suite('number', function() {
    test('integer', function() {
        assert.deepEqual(
            Interpreter.evalScheem(3),
            3
        );
    });
    test('float', function() {
        assert.deepEqual(
            Interpreter.evalScheem(4.4),
            4.4
        );
    });
    test('negative', function() {
        assert.deepEqual(
            Interpreter.evalScheem(-5),
            -5
        );
    });
});

suite('add', function() {
    test(' 2 and 2', function() {
        assert.deepEqual(
            Interpreter.evalScheem(['+', 2, 2]),
            4
        );
    });
    test('two numbers', function() {
        assert.deepEqual(
            Interpreter.evalScheem(['+', 3, 5]),
            8
        );
    });
    test('a number and an expression', function() {
        assert.deepEqual(
            Interpreter.evalScheem(['+', 3, ['+', 2, 2]]),
            7
        );
    });
	test('a dog and a cat', function() {
		expect(function () {
			Interpreter.evalScheem(['+', 'dog', 'cat']);
		}).to.throw();
	});	
	test('a dog and 2', function() {
		expect(function () {
			Interpreter.evalScheem(['+', 'dog', 2]);
		}).to.throw();
	});		
	test('3 and a cat', function() {
		expect(function () {
			Interpreter.evalScheem(['+', 3, 'cat']);
		}).to.throw();
	});		
	test('2 and a "2"', function() {
		expect(function () {
			Interpreter.evalScheem(['+', 2, '2']);
		}).to.throw();
	});	
	test('1 and a 2 and 3', function() {
		expect(function () {
			Interpreter.evalScheem(['+', 1, 2, 3]);
		}).to.throw();
	});		
	test('nothing to add', function() {
		expect(function () {
			Interpreter.evalScheem(['+']);
		}).to.throw();
	});			
})

suite('minus', function() {
    test(' 2 and 2', function() {
        assert.deepEqual(
            Interpreter.evalScheem(['-', 2, 2]),
            0
        );
    });
    test('two numbers', function() {
        assert.deepEqual(
            Interpreter.evalScheem(['-', 3, 5]),
            -2
        );
    });
    test('a number and an expression', function() {
        assert.deepEqual(
            Interpreter.evalScheem(['-', 3, ['-', 2, 2]]),
            3
        );
    });
})

suite('times', function() {
    test(' 2 and 2', function() {
        assert.deepEqual(
            Interpreter.evalScheem(['*', 2, 2]),
            4
        );
    });
    test('two numbers', function() {
        assert.deepEqual(
            Interpreter.evalScheem(['*', 3, 5]),
            15
        );
    });
    test('a number and an expression', function() {
        assert.deepEqual(
            Interpreter.evalScheem(['*', 3, ['*', 2, 2]]),
            12
        );
    });
})

suite('variables', function(){
	
    test('x test', function() {
		var env = Interpreter.createBasicEnv({x:2, y:3, z:10});
        assert.deepEqual(
            Interpreter.evalScheem('x', env),
            2
        );
    });		
    test('evaluation of define test', function(){
		var env = Interpreter.createBasicEnv({x:2, y:3, z:10});
		var tmp = Interpreter.evalScheem(['define', 'a', 5], env);
		assert.deepEqual(tmp, 0);
	});	
	test('define already defined', function() {
		var env = Interpreter.createBasicEnv({x:2, y:3, z:10});
		expect(function () {
			Interpreter.evalScheem(['define', 'x', 5], env);
		}).to.throw();
	});		
    test('define to list', function(){
		var env = Interpreter.createBasicEnv({x:2, y:3, z:10});
		var tmp = Interpreter.evalScheem(['define', 'a', ['quote', [5, 6, 7]]], env);
		assert.deepEqual(env.bindings.x, 2);
		assert.deepEqual(env.bindings.y, 3);
		assert.deepEqual(env.bindings.z, 10);
		assert.deepEqual(env.bindings.a, [5,6,7]);
		assert.deepEqual(env.outer, {});
	});		
	test('define too many', function() {
		var env = Interpreter.createBasicEnv({x:2, y:3, z:10});
		expect(function () {
			Interpreter.evalScheem(['define', 'a', 5, 6, 7], env);
		}).to.throw();
	});		
 	test('define too few', function() {
		var env = Interpreter.createBasicEnv({x:2, y:3, z:10});
		expect(function () {
			Interpreter.evalScheem(['define', 'a'], env);
		}).to.throw();
	});	
	test('set! not defined', function() {
		var env = Interpreter.createBasicEnv({x:2, y:3, z:10});
		expect(function () {
			Interpreter.evalScheem(['set!', 'yyyyy', 5], env);
		}).to.throw();
	});	
	test('set! too many', function() {
		var env = Interpreter.createBasicEnv({x:2, y:3, z:10});
		expect(function () {
			Interpreter.evalScheem(['set!', 'a', 5, 6, 7], env);
		}).to.throw();
	});		
 	test('set! too few', function() {
		var env = Interpreter.createBasicEnv({x:2, y:3, z:10});
		expect(function () {
			Interpreter.evalScheem(['set!', 'a'], env);
		}).to.throw();
	});		
    test('(set! y (+ x 1)) test', function(){
		var env = Interpreter.createBasicEnv({x:2, y:0, z:10});
		var tmp = Interpreter.evalScheem(['set!', 'y', ['+', 'x', 1]], env);
		assert.deepEqual(env.bindings.x, 2);
		assert.deepEqual(env.bindings.y, 3);
		assert.deepEqual(env.bindings.z, 10);
		assert.deepEqual(env.outer, {});
	});		
})

suite('begin', function(){
    test('(begin 99) test', function(){
		assert.deepEqual(Interpreter.evalScheem(['begin', 99]), 99);
	});
    test('(begin 1 2 3) test', function(){
		assert.deepEqual(Interpreter.evalScheem(['begin', 1, 2, 3]), 3);
	});
    test('(begin (+ 2 2) test', function(){
		assert.deepEqual(Interpreter.evalScheem(['begin', ['+', 2, 2]]), 4);
	});	
    test('(begin x y x) test', function(){
		var env = Interpreter.createBasicEnv({x:1});
		assert.deepEqual(Interpreter.evalScheem(['begin', 'x', 'y', 'x'], env), 1);
	});	
    test('(begin (set! x 5) (set! x (+ y x) x)) test', function(){
		assert.deepEqual(Interpreter.evalScheem(['begin', ['set!', 'x', 5], ['set!', 'x', ['+', 'y', 'x']], 'x'], Interpreter.createBasicEnv({x:1, y:2})), 7);
	});	
 	test('begin too few', function() {
		expect(function () {
			Interpreter.evalScheem(['begin']);
		}).to.throw();
	});		
});

suite('quote', function() {
    test('a number', function() {
        assert.deepEqual(
            Interpreter.evalScheem(['quote', 3]),
            3
        );
    });
    test('an atom', function() {
        assert.deepEqual(
            Interpreter.evalScheem(['quote', 'dog']),
            'dog'
        );
    });
    test('a list', function() {
        assert.deepEqual(
            Interpreter.evalScheem(['quote', [1, 2, 3]]),
            [1, 2, 3]
        );
    });
});

suite('list operations', function(){
    test('(cons 1 \'(2 3)) test', function() {
        assert.deepEqual(
            Interpreter.evalScheem(['cons', 1, ['quote', [2, 3]]]),
			[1, 2, 3]
        );
    });
    test('(cons \'(1 2) \'(3 4)) test', function() {
        assert.deepEqual(
            Interpreter.evalScheem(['cons', ['quote', [1, 2]], ['quote', [3, 4]]]),
			[[1, 2], 3, 4]
        );
    });	
 	test('cons no list', function() {
		expect(function () {
			Interpreter.evalScheem(['cons', 1, 3], {});
		}).to.throw();
	});
	test('cons too many', function() {
		var env = {x:2, y:3, z:10};
		expect(function () {
			Interpreter.evalScheem(['cons', 1, ['quote', [2, 3]], ['quote', [2, 3]]] )
		}).to.throw();
	});		
 	test('cons too few', function() {
		var env = {x:2, y:3, z:10};
		expect(function () {
			Interpreter.evalScheem(['cons', 1])
		}).to.throw();
	});		
    test('(car \'((1 2) 3 4)) test', function() {
        assert.deepEqual(
            Interpreter.evalScheem(['car', ['quote', [[1, 2], 3, 4]]]),
			[1, 2]
        );
    });	
 	test('car no list', function() {
		expect(function () {
			Interpreter.evalScheem(['car', 1]);
		}).to.throw();
	});	
 	test('car empty list', function() {
		expect(function () {
			Interpreter.evalScheem(['car', []]);
		}).to.throw();
	});		
	test('car too many', function() {
		var env = {x:2, y:3, z:10};
		expect(function () {
			Interpreter.evalScheem(['car', ['quote', [2, 3]], ['quote', [2, 3]]] )
		}).to.throw();
	});		
 	test('car too few', function() {
		var env = {x:2, y:3, z:10};
		expect(function () {
			Interpreter.evalScheem(['car'])
		}).to.throw();
	});	
    test('(cdr \'((1 2) 3 4)) test', function() {
        assert.deepEqual(
            Interpreter.evalScheem(['cdr', ['quote', [[1, 2], 3, 4]]]),
			[3, 4]
        );
    });
    test('(cdr \'(2)) test', function() {
        assert.deepEqual(
            Interpreter.evalScheem(['cdr', ['quote', [2]]]),
			[]
        );
    });	
 	test('cdr no list', function() {
		expect(function () {
			Interpreter.evalScheem(['cdr', 1]);
		}).to.throw();
	});	
 	test('cdr empty list', function() {
		expect(function () {
			Interpreter.evalScheem(['cdr', []]);
		}).to.throw();
	});	
	test('cdr too many', function() {
		expect(function () {
			Interpreter.evalScheem(['cdr', ['quote', [2, 3]], ['quote', [2, 3]]] )
		}).to.throw();
	});		
 	test('cdr too few', function() {
		expect(function () {
			Interpreter.evalScheem(['cdr'])
		}).to.throw();
	});		
});	

suite('equal and if', function(){
    test('(if (= 1 1) 2 3) test', function() {
        assert.deepEqual(
            Interpreter.evalScheem(['if', ['=', 1, 1], 2, 3]), 2
        );
    });
	test('equal too many', function() {
		expect(function () {
			Interpreter.evalScheem(['=', 1, 2, 4] )
		}).to.throw();
	});		
 	test('equal too few', function() {
		expect(function () {
			Interpreter.evalScheem(['='])
		}).to.throw();
	});		
	
    test('(if (= 1 0) 2 3) test', function() {
        assert.deepEqual(
            Interpreter.evalScheem(['if', ['=', 1, 0], 2, 3]), 3
        );
    });	
	
    test('(if (= 1 1) 2 error) test', function() {
        assert.deepEqual(
            Interpreter.evalScheem(['if', ['=', 1, 1], 2, 'error']), 2
        );
    });		
	
    test('(if (= 1 1) error 3) test', function() {
        assert.deepEqual(
            Interpreter.evalScheem(['if', ['=', 1, 0], 'error', 3]), 3
        );
    });		
	
    test('(if (= 1 1) (if (= 2 3) 10 11) 12) test', function() {
        assert.deepEqual(
            Interpreter.evalScheem(['if', ['=', 1, 1], ['if', ['=', 2, 3], 10, 11], 12]), 11
        );
    });		
	test('if too many', function() {
		expect(function () {
			 Interpreter.evalScheem(['if', ['=', 1, 0], 2, 3, 4])
		}).to.throw();
	});		
 	test('if too few', function() {
		expect(function () {
			 Interpreter.evalScheem(['if', ['=', 1, 0], 2])
		}).to.throw();
	});
	test('if not boolean', function() {
		expect(function () {
			 Interpreter.evalScheem(['if', 4444, 2, 3])
		}).to.throw();
	});		
});

suite('minor', function(){
    test('(< 2 2) test', function() {
        assert.deepEqual(
            Interpreter.evalScheem(['<', 2, 2]), '#f'
        );
    });
    test('(< 2 3) test', function() {
        assert.deepEqual(
            Interpreter.evalScheem(['<', 2, 3]), '#t'
        );
    });	
    test('(< (+ 1 1) (+ 2 3)) test', function() {
        assert.deepEqual(
            Interpreter.evalScheem(['<', ['+', 1, 1], ['+', 2, 3]]), '#t'
        );
    });		
	test('minor too many', function() {
		expect(function () {
			 Interpreter.evalScheem(['<', 2, 3, 4])
		}).to.throw();
	});		
 	test('minor too few', function() {
		expect(function () {
			 Interpreter.evalScheem(['<', 2])
		}).to.throw();
	});
 	test('minor not numeric', function() {
		expect(function () {
			 Interpreter.evalScheem(['<', 2 , 'dog'])
		}).to.throw();
	});	
 	test('minor not numeric', function() {
		expect(function () {
			 Interpreter.evalScheem(['<', 'dog', 3])
		}).to.throw();
	});	
});

suite('function application', function(){
	
 	test('function 1 argument', function() {	
		var functionPlusOne = function(a){return a + 1;};
        assert.deepEqual(
            Interpreter.evalScheem(['functionPlusOne', 1], Interpreter.createBasicEnv({'functionPlusOne': functionPlusOne})), 2);
	});	
 	test('function 0 argument', function() {	
		var functionAlways3 = function(){return 3;};
        assert.deepEqual(
            Interpreter.evalScheem(['functionAlways3'], Interpreter.createBasicEnv({'functionAlways3': functionAlways3})), 3);
	});		
 	test('function 4 argument', function() {	
		var functionSum4 = function(a, b , c , d){return a + b + c + d;};
        assert.deepEqual(
            Interpreter.evalScheem(['functionSum4', 1, 2, 3, 4], Interpreter.createBasicEnv({'functionSum4': functionSum4})), 10);
	});			
});

suite('lambda-one', function(){
	test('a function gets created', function(){
		//(define plusone (lambda (x) (+ x 1)))
		var env = Interpreter.createBasicEnv();
		Interpreter.evalScheem(['define', 'plusone', ['lambda-one', 'x', ['+', 'x', 1]]], env);
		var functionPlusOne = env.bindings['plusone'];
		assert.deepEqual(typeof functionPlusOne, 'function');	
		assert.deepEqual(functionPlusOne(5), 6);
	})
	test('identity', function(){
		var env = Interpreter.createBasicEnv();
		Interpreter.evalScheem(['define', 'identity', ['lambda-one', 'x', 'x']], env);
		var functionIdentity = env.bindings['identity'];
		assert.deepEqual(typeof functionIdentity, 'function');	
		assert.deepEqual(functionIdentity(5), 5);
	})	
 	test('lambda-one too few', function() {
		expect(function () {
			 Interpreter.evalScheem(['lambda-one', 'x'])
		}).to.throw();
	});	
 	test('lambda-one too many', function() {
		expect(function () {
			 Interpreter.evalScheem(['lambda-one', 'x', ['x'], [3]])
		}).to.throw();
	});		
});

suite('lambda', function(){
	test('a function gets created', function(){
		var env = Interpreter.createBasicEnv();//(define plusone (lambda (x) (+ x 1)))
		Interpreter.evalScheem(['define', 'add2', ['lambda', ['x', 'y'], ['+', 'x', 'y']]], env);
		var add2 = env.bindings['add2'];
		assert.deepEqual(typeof add2, 'function');	
		assert.deepEqual(add2(5, 6), 11);
	})
	test('identity', function(){
		var env = Interpreter.createBasicEnv();
		Interpreter.evalScheem(['define', 'identity', ['lambda', ['x'], 'x']], env);
		var functionIdentity = env.bindings['identity'];
		assert.deepEqual(typeof functionIdentity, 'function');	
		assert.deepEqual(functionIdentity(5), 5);
	})	
 	test('lambda too few', function() {
		expect(function () {
			 Interpreter.evalScheem(['lambda', ['x']], {bindings:{}, outer:{}})
		}).to.throw();
	});	
 	test('lambda too many', function() {
		expect(function () {
			 Interpreter.evalScheem(['lambda', ['x'], ['x'], [3]], {bindings:{}, outer:{}})
		}).to.throw();
	});		
 	test('lambda args shoud be a list', function() {
		expect(function () {
			 Interpreter.evalScheem(['lambda', 'x', ['x']], {bindings:{}, outer:{}})
		}).to.throw();
	});		
	test('Calling an anonymous function', function(){
		var result = Interpreter.evalScheem([['lambda', ['x', 'y'], ['+', 'x', 'y']], 5 , 6]);
		assert.deepEqual(result, 11);
	});
	test('Passing a function as a value to another function', function(){
		var result = Interpreter.evalScheem(['begin', 
			['define', 'add2', ['lambda', ['x', 'y'], ['+', 'x', 'y']]],
			['define', 'apply', ['lambda', ['f', 'a', 'b'], ['f', 'a', 'b']]],
			['apply', 'add2', 3, 4]			
			]);

		assert.deepEqual(result, 7);
	});	
	test('Argument to a function shadows a global variable', function(){
		var env = Interpreter.createBasicEnv({x:1, y:2}); 
		var result = Interpreter.evalScheem([['lambda', ['x', 'y'], ['+', 'x', 'y']], 5 , 6], env);
		assert.deepEqual(result, 11);
	});	
	
	test('function reads a global variable', function(){
		var env = Interpreter.createBasicEnv({x:1, y:2}); 
		var result = Interpreter.evalScheem([['lambda', ['y'], ['+', 'x', 'y']], 5], env);
		assert.deepEqual(result, 6);
	});	

	test('A function modifies a global variable', function(){
		var env = Interpreter.createBasicEnv({x:1, y:2}); 
		Interpreter.evalScheem([['lambda', ['x'], ['set!', 'y', 33]], 5], env);
		assert.deepEqual(env.bindings.y, 33);
	});		
	test('Inner function uses values from enclosing function', function(){
		var result = Interpreter.evalScheem([['lambda', ['x'], [['lambda', ['y'], ['+', 'x', 'y']], 3]], 5]);
		assert.deepEqual(result, 8);
	});		
	test('An inner function modifies a variable in the outer function', function(){
		var result = Interpreter.evalScheem([['lambda', ['x'], ['begin', [['lambda', ['y'], ['set!', 'x', 'y']], 3], 'x']], 5]);
		assert.deepEqual(result, 3);
	});		
	
	test('An outer function returns an inner function', function(){
		var result = Interpreter.evalScheem([['lambda', [], ['lambda', ['y'], ['+', 'y', 8]]]]);
		assert.deepEqual(typeof result, 'function');	
		assert.deepEqual(result(1), 9);
	});		
	
	test('An outer function returns an inner function, inner function refers to outer function variables', function(){
		var result = Interpreter.evalScheem(['lambda', ['x'], [['lambda', ['y'], ['+', 'x', 'y']], 3]]);
		assert.deepEqual(typeof result, 'function');	
		assert.deepEqual(result(5), 8);
	});		
	test(' A function in a define that calls itself recursively', function(){
		var env = Interpreter.createBasicEnv(); 
		Interpreter.evalScheem(['define', 'fact', 
		['lambda', ['n'], [
			'if', ['=', 0, 'n'],
				1 ,
			   ['*' ,
				  'n' ,
				  ['fact' ,
					 ['-'  ,
						'n' ,
						 1]]]]]] , env);
		var fact = env.bindings['fact'];
		assert.deepEqual(typeof fact, 'function');	
		assert.deepEqual(fact(0), 1);
		assert.deepEqual(fact(3), 6);
		assert.deepEqual(fact(4), 24);
	});	
});

suite('more functions', function(){
	test('length of empty list', function(){
		var result = Interpreter.evalScheem(['length', ['quote', []]]);
		assert.deepEqual(result, 0);
	});	
	test('length of list 1 2 3 4', function(){
		var result = Interpreter.evalScheem(['length', ['quote', [1,2,3,4]]]);
		assert.deepEqual(result, 4);
	});	
 	test('length args shoud be a list', function() {
		expect(function () {
			 Interpreter.evalScheem(['length', 3]);
		}).to.throw();
	});		
 	test('length too few', function() {
		expect(function () {
			 Interpreter.evalScheem(['length']);
		}).to.throw();
	});	
 	test('length too many', function() {
		expect(function () {
			 Interpreter.evalScheem(['length', ['quote', [1]], ['quote', [1,2]]]);
		}).to.throw();
	});		
	
	test('isEmpty? of empty list', function(){
		var result = Interpreter.evalScheem(['isEmpty?', ['quote', []]]);
		assert.deepEqual(result, '#t');
	});	
	test('isEmpty? of list 1 2 3 4', function(){
		var result = Interpreter.evalScheem(['isEmpty?', ['quote', [1,2,3,4]]]);
		assert.deepEqual(result, '#f');
	});	
 	test('isEmpty? args shoud be a list', function() {
		expect(function () {
			 Interpreter.evalScheem(['isEmpty?', 3]);
		}).to.throw();
	});		
 	test('isEmpty? too few', function() {
		expect(function () {
			 Interpreter.evalScheem(['isEmpty?']);
		}).to.throw();
	});	
 	test('isEmpty? too many', function() {
		expect(function () {
			 Interpreter.evalScheem(['isEmpty?', ['quote', [1]], ['quote', [1,2]]]);
		}).to.throw();
	});	
	
	test('append of two lists', function(){
		var result = Interpreter.evalScheem(['append', ['quote', [1,2]], ['quote', [3,4]]]);
		assert.deepEqual(result, [1,2,3,4]);
	});	
	test('append of list and empty', function(){
		var result = Interpreter.evalScheem(['append', ['quote', [1,2]], ['quote', []]]);
		assert.deepEqual(result, [1,2]);
	});	
	test('append of empty and list', function(){
		var result = Interpreter.evalScheem(['append', ['quote', []], ['quote', [3,4]]]);
		assert.deepEqual(result, [3,4]);
	});		
 	test('append args shoud be lists', function() {
		expect(function () {
			 var result = Interpreter.evalScheem(['append', 2, ['quote', [3,4]]]);
		}).to.throw();
	});		
 	test('append args shoud be lists 2', function() {
		expect(function () {
			 var result = Interpreter.evalScheem(['append', ['quote', [3,4]]], 3);
		}).to.throw();
	});	
 	test('append too few', function() {
		expect(function () {
			 Interpreter.evalScheem(['append', ['quote', [1]]]);
		}).to.throw();
	});	
 	test('append too many', function() {
		expect(function () {
			 Interpreter.evalScheem(['append', ['quote', [1]], ['quote', [1,2]], ['quote', [1]]]);
		}).to.throw();
	});		
	
	test('isList? of empty list', function(){
		var result = Interpreter.evalScheem(['isList?', ['quote', []]]);
		assert.deepEqual(result, '#t');
	});	
	test('isList? of list 1 2 3 4', function(){
		var result = Interpreter.evalScheem(['isList?', ['quote', [1,2,3,4]]]);
		assert.deepEqual(result, '#t');
	});	
	test('isList? of 3', function(){
		var result = Interpreter.evalScheem(['isList?', ['quote', 3]]);
		assert.deepEqual(result, '#f');
	});	
 	test('isList? too few', function() {
		expect(function () {
			 Interpreter.evalScheem(['isList?']);
		}).to.throw();
	});	
 	test('isList? too many', function() {
		expect(function () {
			 Interpreter.evalScheem(['isList?', ['quote', [1]], ['quote', [1,2]]]);
		}).to.throw();
	});		
})

suite('parser smoke test', function() {
    test('a number', function() {
        assert.deepEqual(
            SCHEEM.parse('42'),
            42
        );
    });
    test('a variable', function() {
        assert.deepEqual(
            SCHEEM.parse('x'),
            'x'
        );
    });
});

suite('parser basic tests', function() {
    test('parse("atom")', function() {
		assert.deepEqual(SCHEEM.parse("atom"), "atom");
    });
    test('parse("+")', function() {
		assert.deepEqual(SCHEEM.parse("+"), "+");
    });	
    test('parse("(+ x 3)")', function() {
		assert.deepEqual(SCHEEM.parse("(+ x 3)"), ["+", "x",  3]);
    });		
    test('parse("(+ 1 (f x 3 y))")', function() {
		assert.deepEqual(SCHEEM.parse("(+ 1 (f x 3 y))"), ["+", 1, ["f", "x", 3, "y"]]);	
    });		
});

suite('parser spaces between atoms', function() {
    test('parse("(+    x     3)")', function() {
		assert.deepEqual(SCHEEM.parse("(+   x    3)"), ["+", "x", 3]);
    });
    test('parse("(   +    x    3)")', function() {
		assert.deepEqual(SCHEEM.parse("(    +   x    3)"), ["+", "x", 3]);
    });	
    test('parse("(   +    x    3   )")', function() {
		assert.deepEqual(SCHEEM.parse("(    +   x    3    )"), ["+", "x", 3]);
    });		
    test('parse("  (  +   1   (  f   x   3   y  )  )")', function() {
		assert.deepEqual(SCHEEM.parse("(  +   1   (   f    x    3     y  )   )"), ["+", 1, ["f", "x", 3, "y"]]);
    });		
});

suite('parser enters and tabs', function() {
    test('parse("(+ \n   x  \t   3)")', function() {
		assert.deepEqual(SCHEEM.parse("(+  \n x \t   3)"), ["+", "x", 3]);
    });
    test('parse("(  \r\n +    x    3)")', function() {
		assert.deepEqual(SCHEEM.parse("(  \r\n  + \t  x \r\n   3)"), ["+", "x", 3]);
    });	
    test('parse("(   +    x    3   )")', function() {
		assert.deepEqual(SCHEEM.parse("(  \r\n  +\t   x\t    3\t    )"), ["+", "x", 3]);
    });		
    test('parse("  (  +   1   (  f   x   3   y  )  )")', function() {
		assert.deepEqual(SCHEEM.parse("( \r\n + \r\n  1   (\r\n   f\t    x\r\n    3\r\n     y\t  )  \t )"), ["+", 1, ["f", "x", 3, "y"]]);
    });	
});

suite('parser quotes', function() {
    test('parse("\'x")', function() {
		assert.deepEqual(SCHEEM.parse("'x"), ["quote", "x"]);
    });
    test('parse("\'  x")', function() {
		assert.deepEqual(SCHEEM.parse("'   x"), ["quote", "x"]);
    });	
    test('parse("\'(1 2 3))', function() {
		assert.deepEqual(SCHEEM.parse("'(1 2 3)"), ["quote", [1, 2, 3]]);
    });		
});

suite('parser comments', function() {
    test('parse(";;comment\natom")', function() {
		assert.deepEqual(SCHEEM.parse(";;comment\natom"), "atom");
    });
    test('parse(";;comment\natom;;comment\n")', function() {
		assert.deepEqual(SCHEEM.parse(";;comment\natom;;comment\n"), "atom");
    });
    test('parse(";;comment\natom;;comment")', function() {
		assert.deepEqual(SCHEEM.parse(";;comment\natom;;comment"), "atom");
    });
    test('parse(";;comment\n(a b);;comment")', function() {
		assert.deepEqual(SCHEEM.parse(";;comment\n(a b);;comment"), ["a", "b"]);
    });
    test('parse(";;comment\n(a ;;comment)b;;comment\n")', function() {
		assert.deepEqual(SCHEEM.parse(";;comment\n(a ;;comment\nb;;comment\n)"), ["a", "b"]);
    });	
	
    test('commments at beggining', function() {
		assert.deepEqual(SCHEEM.parse(";;comment\n;;comment\n(a b c d)"), ["a", "b", "c", "d"]);
    });
    test('commments at end', function() {
		assert.deepEqual(SCHEEM.parse("(a b c d);;comment\n"), ["a", "b", "c", "d"]);
    });
    test('commments at end no newline', function() {
		assert.deepEqual(SCHEEM.parse("(a b c d);;comment"), ["a", "b", "c", "d"]);
    });
    test('commments after first element', function() {
		assert.deepEqual(SCHEEM.parse("(a;;comment\n   \n  ;;comment\n b c d);;comment"), ["a", "b", "c", "d"]);
    });	
	
	test('commments after second element', function() {
		assert.deepEqual(SCHEEM.parse("(a b;;comment\n   \n  ;;comment\n  c d);;comment"), ["a", "b", "c", "d"]);
    });
    test('commments before closing', function() {
		assert.deepEqual(SCHEEM.parse("(a b c d ;;comment\n)"), ["a", "b", "c", "d"]);
    });
    test('commments before closing no space', function() {
		assert.deepEqual(SCHEEM.parse("(a b c d;;comment\n)"), ["a", "b", "c", "d"]);
    });
    test('commments everywhere', function() {
		assert.deepEqual(SCHEEM.parse(";;comment\n;;comment\n(;;comment\n;;comment\n  ;;comment\n;;comment\na ;;comment\n   b\n;;comment\n\nc \n;;comment d)\n;;comment\n   ;;comment\n\n\n\nd \n;;comment\n)\n;;comment\n;;comment\n"), ["a", "b", "c", "d"]);
    });	
});

suite('evalScheemString', function() {
    test('a number', function() {
        assert.deepEqual(
            Interpreter.evalScheemString('42'),
            42
        );
    });
    test('a variable', function() {
        assert.deepEqual(
            Interpreter.evalScheemString('x', Interpreter.createBasicEnv({x:33})),
            33
        );
    });
    test('an operation with variables', function() {
        assert.deepEqual(
            Interpreter.evalScheemString('(+ x y)', Interpreter.createBasicEnv({x:2, y:3})),
            5
        );
    });	
    test('a quote', function() {
        assert.deepEqual(
            Interpreter.evalScheemString('\'dog'),
            'dog'
        );
    });	
});


  </script>
  <script>
    $(function(){
      mocha.run();
    });
  </script>

</head>
<body>
  <div id="mocha"></div>
</body>
</html>
